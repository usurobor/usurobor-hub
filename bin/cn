#!/usr/bin/env node

/**
 * cn - Coherent Network agent CLI
 * 
 * This is a thin wrapper that routes to the appropriate tool.
 * OCaml source in tools/src/cn/, bundled JS in dist/cn.js
 */

const { execSync, spawn } = require('child_process');
const path = require('path');
const fs = require('fs');

const VERSION = '2.0.7';

// Colors (respects NO_COLOR)
const noColor = process.env.NO_COLOR !== undefined;
const c = {
  reset: noColor ? '' : '\x1b[0m',
  green: noColor ? '' : '\x1b[32m',
  red: noColor ? '' : '\x1b[31m',
  yellow: noColor ? '' : '\x1b[33m',
  cyan: noColor ? '' : '\x1b[36m',
  magenta: noColor ? '' : '\x1b[35m',
  dim: noColor ? '' : '\x1b[2m',
};

const ok = (msg) => console.log(`${c.green}✓ ${msg}${c.reset}`);
const fail = (msg) => console.log(`${c.red}✗ ${msg}${c.reset}`);
const info = (msg) => console.log(`${c.cyan}${msg}${c.reset}`);
const warn = (msg) => console.log(`${c.yellow}⚠ ${msg}${c.reset}`);
const cmd = (msg) => `${c.magenta}${msg}${c.reset}`;

const HELP = `cn - Coherent Network agent CLI

Usage: cn <command> [options]

Commands:
  init [name]         Create new hub
  status              Show hub state
  
  thread              Thread operations (agent-facing API)
    list [--inbox|--outbox|--daily]   List threads
    new <title> [--to <peer>|--daily|--adhoc]  Create thread
    show <id>         Show thread content
    reply <id> <msg>  Reply to thread
    close <id>        Archive thread
    fetch             Check for inbound threads
    send              Send pending outbound
    sync              Fetch + send
  
  commit [msg]        Stage all changes and commit
  push                Push to origin
  save [msg]          Commit + push (convenience)
  peer                Manage peers
  doctor              Check system health
  update              Update cn to latest version

Aliases:
  i = inbox, s = status, d = doctor

Flags:
  --help, -h          Show help
  --version, -V       Show version

Examples:
  cn init sigma       Create hub named 'sigma'
  cn inbox check      List inbound branches
  cn doctor           Check system health
`;

// Expand aliases
const aliases = { i: 'inbox', o: 'outbox', s: 'status', d: 'doctor', p: 'peer', t: 'thread' };
const expandAlias = (cmd) => aliases[cmd] || cmd;

// Find hub path
function findHubPath() {
  let dir = process.cwd();
  while (dir !== '/') {
    if (fs.existsSync(path.join(dir, '.cn', 'config.json'))) {
      return dir;
    }
    // Also check for cn-* pattern with state/peers.md
    if (fs.existsSync(path.join(dir, 'state', 'peers.md'))) {
      return dir;
    }
    dir = path.dirname(dir);
  }
  return null;
}

// Derive name from path
function deriveName(hubPath) {
  const base = path.basename(hubPath);
  return base.startsWith('cn-') ? base.slice(3) : base;
}

// Append-only action log
function logAction(hubPath, action, details = {}) {
  const logsDir = path.join(hubPath, 'logs');
  if (!fs.existsSync(logsDir)) {
    fs.mkdirSync(logsDir, { recursive: true });
  }
  const entry = {
    ts: new Date().toISOString(),
    action,
    ...details
  };
  fs.appendFileSync(
    path.join(logsDir, 'cn.log'),
    JSON.stringify(entry) + '\n'
  );
}

// Run inbox commands (threads/inbox/ model)
function runInbox(subCmd, hubPath, name) {
  const inboxDir = path.join(hubPath, 'threads', 'inbox');
  const peersPath = path.join(hubPath, 'state', 'peers.md');
  
  // Ensure inbox dir exists
  if (!fs.existsSync(inboxDir)) {
    fs.mkdirSync(inboxDir, { recursive: true });
  }
  
  // Load peers
  let peers = {};
  if (fs.existsSync(peersPath)) {
    const peersContent = fs.readFileSync(peersPath, 'utf8');
    peers = parsePeers(peersContent);
  }
  
  if (subCmd === 'check') {
    // Actor model: check MY repo for inbound branches from peers (peer/*)
    info(`Checking inbox for ${name}...`);
    
    // Fetch my own repo
    try {
      execSync('git fetch origin', { cwd: hubPath, stdio: 'pipe' });
    } catch (err) {
      warn('Failed to fetch origin');
    }
    
    let totalInbound = 0;
    
    for (const [peerName, peer] of Object.entries(peers)) {
      if (peer.kind === 'template') continue; // Skip template repo
      
      try {
        // Find branches from this peer in MY repo (peerName/*)
        const branches = execSync(`git branch -r | grep "origin/${peerName}/" | sed 's/.*origin\\///'`, { 
          cwd: hubPath, 
          encoding: 'utf8',
          stdio: ['pipe', 'pipe', 'pipe']
        }).trim().split('\n').filter(b => b);
        
        if (branches.length > 0) {
          logAction(hubPath, 'inbox.fetch', { from: peerName, branches, count: branches.length });
          warn(`From ${peerName}: ${branches.length} inbound`);
          branches.forEach(b => console.log(`  ← ${b}`));
          totalInbound += branches.length;
        } else {
          console.log(`  ${c.dim}${peerName}: no inbound${c.reset}`);
        }
      } catch (err) {
        // No branches found
        console.log(`  ${c.dim}${peerName}: no inbound${c.reset}`);
      }
    }
    
    if (totalInbound === 0) {
      ok('Inbox clear');
    }
    return;
  }
  
  if (subCmd === 'process') {
    // Actor model: materialize inbound branches from MY repo to threads/inbox/
    info('Processing inbox...');
    let processed = 0;
    
    for (const [peerName, peer] of Object.entries(peers)) {
      if (peer.kind === 'template') continue; // Skip template repo
      
      try {
        // Find branches from this peer in MY repo
        const branches = execSync(`git branch -r | grep "origin/${peerName}/" | sed 's/.*origin\\///'`, { 
          cwd: hubPath, 
          encoding: 'utf8',
          stdio: ['pipe', 'pipe', 'pipe']
        }).trim().split('\n').filter(b => b);
        
        for (const branch of branches) {
          // Get files from this branch
          try {
            const files = execSync(`git diff main...origin/${branch} --name-only 2>/dev/null || git diff master...origin/${branch} --name-only`, {
              cwd: hubPath,
              encoding: 'utf8',
              stdio: ['pipe', 'pipe', 'pipe']
            }).trim().split('\n').filter(f => f.endsWith('.md'));
            
            for (const file of files) {
              // Get file content from branch
              const content = execSync(`git show origin/${branch}:${file}`, {
                cwd: hubPath,
                encoding: 'utf8',
                stdio: ['pipe', 'pipe', 'pipe']
              });
              
              // Write to inbox with metadata
              const inboxFileName = `${peerName}-${path.basename(branch)}.md`;
              const inboxFilePath = path.join(inboxDir, inboxFileName);
              
              // Skip if already materialized
              if (fs.existsSync(inboxFilePath)) {
                continue;
              }
              
              // Add/update frontmatter
              const meta = {
                from: peerName,
                branch: branch,
                file: file,
                received: new Date().toISOString()
              };
              const finalContent = ensureFrontmatter(content, meta);
              fs.writeFileSync(inboxFilePath, finalContent);
              
              logAction(hubPath, 'inbox.materialize', { from: peerName, branch, file, inboxFile: inboxFileName });
              ok(`Materialized: ${inboxFileName}`);
              processed++;
            }
          } catch (err) {
            // Branch might not have files or diff failed
          }
        }
      } catch (err) {
        // No branches found
      }
    }
    
    if (processed === 0) {
      info('No new threads to materialize');
    } else {
      ok(`Processed ${processed} thread(s)`);
    }
    return;
  }
  
  if (subCmd === 'flush') {
    // Scan inbox for agent replies, send back
    info('Scanning inbox for replies...');
    
    const threads = fs.readdirSync(inboxDir)
      .filter(f => f.endsWith('.md'))
      .map(f => {
        const filePath = path.join(inboxDir, f);
        const content = fs.readFileSync(filePath, 'utf8');
        const meta = parseFrontmatter(content);
        return { file: f, path: filePath, content, meta };
      });
    
    let replied = 0;
    for (const t of threads) {
      // Check if agent has replied (look for ## Reply section or reply: true in frontmatter)
      const hasReply = t.meta.reply === 'true' || t.content.includes('\n## Reply\n') || t.content.includes('\n## Response\n');
      
      if (!hasReply) continue;
      
      const from = t.meta.from;
      if (!from) continue;
      
      const peer = peers[from];
      if (!peer || !peer.clone) continue;
      
      try {
        const threadName = path.basename(t.file, '.md');
        const branchName = `${name}/${threadName}-reply`;
        
        // Push reply to peer's clone
        execSync(`git checkout main 2>/dev/null || git checkout master`, { cwd: peer.clone, stdio: 'pipe' });
        execSync(`git pull --ff-only 2>/dev/null || true`, { cwd: peer.clone, stdio: 'pipe' });
        execSync(`git checkout -b ${branchName} 2>/dev/null || git checkout ${branchName}`, { cwd: peer.clone, stdio: 'pipe' });
        
        const peerThreadDir = path.join(peer.clone, 'threads', 'adhoc');
        if (!fs.existsSync(peerThreadDir)) {
          fs.mkdirSync(peerThreadDir, { recursive: true });
        }
        
        // Copy reply thread
        const replyFileName = `${name}-${threadName}-reply.md`;
        fs.copyFileSync(t.path, path.join(peerThreadDir, replyFileName));
        
        execSync(`git add "threads/adhoc/${replyFileName}"`, { cwd: peer.clone, stdio: 'pipe' });
        execSync(`git commit -m "${name}: reply to ${threadName}"`, { cwd: peer.clone, stdio: 'pipe' });
        execSync(`git push -u origin ${branchName} -f`, { cwd: peer.clone, stdio: 'pipe' });
        execSync(`git checkout main 2>/dev/null || git checkout master`, { cwd: peer.clone, stdio: 'pipe' });
        
        // Archive the inbox thread (move to threads/archived/)
        const archivedDir = path.join(hubPath, 'threads', 'archived');
        if (!fs.existsSync(archivedDir)) {
          fs.mkdirSync(archivedDir, { recursive: true });
        }
        const archivedContent = updateFrontmatter(t.content, { replied: new Date().toISOString() });
        fs.writeFileSync(path.join(archivedDir, t.file), archivedContent);
        fs.unlinkSync(t.path);
        
        logAction(hubPath, 'inbox.reply', { to: from, thread: t.file, branch: branchName, result: 'ok' });
        ok(`Replied to ${from}: ${t.file}`);
        replied++;
      } catch (err) {
        logAction(hubPath, 'inbox.reply', { to: from, thread: t.file, result: 'error', error: err.message });
        fail(`Failed to reply: ${err.message}`);
        execSync(`git checkout main 2>/dev/null || git checkout master 2>/dev/null || true`, { cwd: peer.clone, stdio: 'pipe' });
      }
    }
    
    if (replied === 0) {
      info('No replies to send');
    } else {
      ok(`Sent ${replied} reply(s)`);
    }
    return;
  }
}

// Ensure content has frontmatter with given fields
function ensureFrontmatter(content, meta) {
  const existing = parseFrontmatter(content);
  const merged = { ...existing, ...meta };
  
  // Remove existing frontmatter if present
  const withoutFm = content.replace(/^---\n[\s\S]*?\n---\n*/, '');
  
  // Build new frontmatter
  const fmLines = Object.entries(merged).map(([k, v]) => `${k}: ${v}`).join('\n');
  return `---\n${fmLines}\n---\n\n${withoutFm}`;
}

// Run outbox commands (threads/outbox/ model)
function runOutbox(subCmd, hubPath, name) {
  const outboxDir = path.join(hubPath, 'threads', 'outbox');
  const sentDir = path.join(hubPath, 'threads', 'sent');
  const peersPath = path.join(hubPath, 'state', 'peers.md');
  
  // Ensure directories exist
  if (!fs.existsSync(outboxDir)) {
    fs.mkdirSync(outboxDir, { recursive: true });
  }
  if (!fs.existsSync(sentDir)) {
    fs.mkdirSync(sentDir, { recursive: true });
  }
  
  // Load peers
  let peers = {};
  if (fs.existsSync(peersPath)) {
    const peersContent = fs.readFileSync(peersPath, 'utf8');
    peers = parsePeers(peersContent);
  }
  
  // Scan outbox for threads
  const threads = fs.readdirSync(outboxDir)
    .filter(f => f.endsWith('.md'))
    .map(f => {
      const filePath = path.join(outboxDir, f);
      const content = fs.readFileSync(filePath, 'utf8');
      const meta = parseFrontmatter(content);
      return { file: f, path: filePath, content, meta };
    });
  
  if (subCmd === 'check') {
    if (threads.length === 0) {
      ok('Outbox clear');
      return;
    }
    warn(`${threads.length} pending send(s):`);
    threads.forEach(t => {
      const to = t.meta.to || '(no recipient)';
      console.log(`  → ${to}: ${t.file}`);
    });
    return;
  }
  
  if (subCmd === 'flush') {
    if (threads.length === 0) {
      ok('Outbox clear');
      return;
    }
    
    info(`Flushing ${threads.length} thread(s)...`);
    
    for (const t of threads) {
      const to = t.meta.to;
      if (!to) {
        logAction(hubPath, 'outbox.skip', { thread: t.file, reason: 'no recipient (to: field missing)' });
        warn(`Skipping ${t.file}: no 'to:' in frontmatter`);
        continue;
      }
      
      const peer = peers[to];
      if (!peer) {
        logAction(hubPath, 'outbox.skip', { thread: t.file, to, reason: 'unknown peer' });
        fail(`Unknown peer: ${to}`);
        continue;
      }
      
      if (!peer.clone) {
        logAction(hubPath, 'outbox.skip', { thread: t.file, to, reason: 'no clone path configured' });
        fail(`No clone path for peer: ${to}`);
        continue;
      }
      
      try {
        const threadName = path.basename(t.file, '.md');
        const branchName = `${name}/${threadName}`;
        
        // Actor model: push to PEER's repo (their clone)
        // 1. Ensure peer clone is on main and up to date
        execSync(`git checkout main 2>/dev/null || git checkout master`, { cwd: peer.clone, stdio: 'pipe' });
        execSync(`git pull --ff-only 2>/dev/null || true`, { cwd: peer.clone, stdio: 'pipe' });
        
        // 2. Create branch in peer's clone
        execSync(`git checkout -b ${branchName} 2>/dev/null || git checkout ${branchName}`, { cwd: peer.clone, stdio: 'pipe' });
        
        // 3. Copy thread to peer's threads/adhoc/ (standardized location)
        const peerThreadDir = path.join(peer.clone, 'threads', 'adhoc');
        if (!fs.existsSync(peerThreadDir)) {
          fs.mkdirSync(peerThreadDir, { recursive: true });
        }
        const peerThreadPath = path.join(peerThreadDir, t.file);
        fs.copyFileSync(t.path, peerThreadPath);
        
        // 4. Commit and push
        execSync(`git add "threads/adhoc/${t.file}"`, { cwd: peer.clone, stdio: 'pipe' });
        execSync(`git commit -m "${name}: ${threadName}"`, { cwd: peer.clone, stdio: 'pipe' });
        execSync(`git push -u origin ${branchName} -f`, { cwd: peer.clone, stdio: 'pipe' });
        
        // 5. Return to main
        execSync(`git checkout main 2>/dev/null || git checkout master`, { cwd: peer.clone, stdio: 'pipe' });
        
        // Move to sent/
        const sentPath = path.join(sentDir, t.file);
        const sentContent = updateFrontmatter(t.content, { sent: new Date().toISOString() });
        fs.writeFileSync(sentPath, sentContent);
        fs.unlinkSync(t.path);
        
        logAction(hubPath, 'outbox.send', { to, thread: t.file, branch: branchName, clone: peer.clone, result: 'ok' });
        ok(`Sent to ${to}: ${t.file}`);
      } catch (err) {
        logAction(hubPath, 'outbox.send', { to, thread: t.file, result: 'error', error: err.message });
        fail(`Failed to send ${t.file}: ${err.message}`);
        execSync(`git checkout main 2>/dev/null || true`, { cwd: hubPath, stdio: 'pipe' });
      }
    }
    
    ok('Outbox flush complete');
  }
}

// Commit command — agent requests, cn executes
function runCommit(hubPath, name, message) {
  // Check for uncommitted changes
  const status = execSync('git status --porcelain', { cwd: hubPath, encoding: 'utf8' }).trim();
  
  if (!status) {
    info('Nothing to commit');
    return;
  }
  
  // Default message if none provided
  if (!message || message.trim() === '') {
    message = `${name}: auto-commit ${new Date().toISOString().slice(0, 10)}`;
  }
  
  try {
    // Stage all changes
    execSync('git add -A', { cwd: hubPath, stdio: 'pipe' });
    
    // Commit
    execSync(`git commit -m "${message.replace(/"/g, '\\"')}"`, { cwd: hubPath, stdio: 'pipe' });
    
    logAction(hubPath, 'commit', { message, result: 'ok' });
    ok(`Committed: ${message}`);
  } catch (err) {
    logAction(hubPath, 'commit', { message, result: 'error', error: err.message });
    fail(`Commit failed: ${err.message}`);
  }
}

// Push command — push to origin
function runPush(hubPath, name) {
  try {
    // Get current branch
    const branch = execSync('git branch --show-current', { cwd: hubPath, encoding: 'utf8' }).trim();
    
    // Push
    execSync(`git push origin ${branch}`, { cwd: hubPath, stdio: 'pipe' });
    
    logAction(hubPath, 'push', { branch, result: 'ok' });
    ok(`Pushed to origin/${branch}`);
  } catch (err) {
    logAction(hubPath, 'push', { result: 'error', error: err.message });
    fail(`Push failed: ${err.message}`);
  }
}

// Write file — agent requests, cn executes
function runWrite(hubPath, filePath, content) {
  if (!filePath) {
    fail('Usage: cn write <path> <content>');
    fail('       echo "content" | cn write <path>');
    process.exit(1);
  }
  
  // Resolve path relative to hub
  const fullPath = path.isAbsolute(filePath) ? filePath : path.join(hubPath, filePath);
  
  // Security: ensure path is within hub
  if (!fullPath.startsWith(hubPath)) {
    fail('Path must be within hub directory');
    process.exit(1);
  }
  
  // Interpret escape sequences in content
  content = content.replace(/\\n/g, '\n').replace(/\\t/g, '\t');
  
  try {
    // Ensure parent directory exists
    const dir = path.dirname(fullPath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    
    fs.writeFileSync(fullPath, content);
    logAction(hubPath, 'write', { path: filePath, bytes: content.length, result: 'ok' });
    ok(`Wrote ${filePath} (${content.length} bytes)`);
  } catch (err) {
    logAction(hubPath, 'write', { path: filePath, result: 'error', error: err.message });
    fail(`Write failed: ${err.message}`);
  }
}

// Append to file
function runAppend(hubPath, filePath, content) {
  if (!filePath) {
    fail('Usage: cn append <path> <content>');
    process.exit(1);
  }
  
  const fullPath = path.isAbsolute(filePath) ? filePath : path.join(hubPath, filePath);
  
  if (!fullPath.startsWith(hubPath)) {
    fail('Path must be within hub directory');
    process.exit(1);
  }
  
  // Interpret escape sequences
  content = content.replace(/\\n/g, '\n').replace(/\\t/g, '\t');
  
  try {
    fs.appendFileSync(fullPath, content);
    logAction(hubPath, 'append', { path: filePath, bytes: content.length, result: 'ok' });
    ok(`Appended to ${filePath} (${content.length} bytes)`);
  } catch (err) {
    logAction(hubPath, 'append', { path: filePath, result: 'error', error: err.message });
    fail(`Append failed: ${err.message}`);
  }
}

// Make directory
function runMkdir(hubPath, dirPath) {
  if (!dirPath) {
    fail('Usage: cn mkdir <path>');
    process.exit(1);
  }
  
  const fullPath = path.isAbsolute(dirPath) ? dirPath : path.join(hubPath, dirPath);
  
  if (!fullPath.startsWith(hubPath)) {
    fail('Path must be within hub directory');
    process.exit(1);
  }
  
  try {
    fs.mkdirSync(fullPath, { recursive: true });
    logAction(hubPath, 'mkdir', { path: dirPath, result: 'ok' });
    ok(`Created ${dirPath}`);
  } catch (err) {
    logAction(hubPath, 'mkdir', { path: dirPath, result: 'error', error: err.message });
    fail(`Mkdir failed: ${err.message}`);
  }
}

// Remove file
function runRm(hubPath, filePath) {
  if (!filePath) {
    fail('Usage: cn rm <path>');
    process.exit(1);
  }
  
  const fullPath = path.isAbsolute(filePath) ? filePath : path.join(hubPath, filePath);
  
  if (!fullPath.startsWith(hubPath)) {
    fail('Path must be within hub directory');
    process.exit(1);
  }
  
  // Safety: don't allow deleting critical files
  const critical = ['spec/SOUL.md', 'spec/USER.md', 'state/peers.md'];
  const relPath = path.relative(hubPath, fullPath);
  if (critical.includes(relPath)) {
    fail(`Cannot delete critical file: ${relPath}`);
    process.exit(1);
  }
  
  try {
    if (fs.existsSync(fullPath)) {
      const stat = fs.statSync(fullPath);
      if (stat.isDirectory()) {
        fs.rmSync(fullPath, { recursive: true });
      } else {
        fs.unlinkSync(fullPath);
      }
      logAction(hubPath, 'rm', { path: filePath, result: 'ok' });
      ok(`Removed ${filePath}`);
    } else {
      info(`${filePath} does not exist`);
    }
  } catch (err) {
    logAction(hubPath, 'rm', { path: filePath, result: 'error', error: err.message });
    fail(`Remove failed: ${err.message}`);
  }
}

// Thread operations — agent-facing API (no file paths)
function runThread(hubPath, name, args) {
  const subCmd = args[0];
  const subArgs = args.slice(1);
  
  switch (subCmd) {
    case 'list':
      threadList(hubPath, name, subArgs);
      break;
    case 'new':
      threadNew(hubPath, name, subArgs);
      break;
    case 'show':
      threadShow(hubPath, name, subArgs[0]);
      break;
    case 'reply':
      threadReply(hubPath, name, subArgs[0], subArgs.slice(1).join(' '));
      break;
    case 'close':
      threadClose(hubPath, name, subArgs[0]);
      break;
    case 'fetch':
      threadFetch(hubPath, name);
      break;
    case 'send':
      threadSend(hubPath, name);
      break;
    case 'sync':
      threadFetch(hubPath, name);
      threadSend(hubPath, name);
      break;
    default:
      fail(`Unknown thread command: ${subCmd}`);
      console.log('Usage: cn thread <list|new|show|reply|close|fetch|send|sync>');
      process.exit(1);
  }
}

// List threads
function threadList(hubPath, name, args) {
  const filter = args.find(a => a.startsWith('--'))?.slice(2) || 'all';
  const dirs = {
    inbox: path.join(hubPath, 'threads', 'inbox'),
    outbox: path.join(hubPath, 'threads', 'outbox'),
    daily: path.join(hubPath, 'threads', 'daily'),
    adhoc: path.join(hubPath, 'threads', 'adhoc'),
  };
  
  const listDir = (dir, prefix) => {
    if (!fs.existsSync(dir)) return [];
    return fs.readdirSync(dir)
      .filter(f => f.endsWith('.md'))
      .map(f => `${prefix}/${f.replace('.md', '')}`);
  };
  
  let threads = [];
  if (filter === 'all' || filter === 'inbox') threads.push(...listDir(dirs.inbox, 'inbox'));
  if (filter === 'all' || filter === 'outbox') threads.push(...listDir(dirs.outbox, 'outbox'));
  if (filter === 'all' || filter === 'daily') threads.push(...listDir(dirs.daily, 'daily'));
  if (filter === 'all' || filter === 'adhoc') threads.push(...listDir(dirs.adhoc, 'adhoc'));
  
  if (threads.length === 0) {
    info('No threads');
  } else {
    console.log(`Threads (${threads.length}):`);
    threads.forEach(t => console.log(`  ${t}`));
  }
}

// Create new thread
function threadNew(hubPath, name, args) {
  const title = args.find(a => !a.startsWith('--'));
  const toFlag = args.find(a => a.startsWith('--to='))?.slice(5);
  const isDaily = args.includes('--daily');
  const isAdhoc = args.includes('--adhoc');
  
  if (!title) {
    fail('Usage: cn thread new <title> [--to <peer>|--daily|--adhoc]');
    process.exit(1);
  }
  
  // Determine directory and ID
  let dir, threadId, frontmatter;
  const slug = title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
  const today = new Date().toISOString().slice(0, 10).replace(/-/g, '');
  
  if (toFlag) {
    dir = path.join(hubPath, 'threads', 'outbox');
    threadId = `outbox/${slug}`;
    frontmatter = `---\nto: ${toFlag}\ncreated: ${new Date().toISOString()}\n---\n\n`;
  } else if (isDaily) {
    dir = path.join(hubPath, 'threads', 'daily');
    threadId = `daily/${today}`;
    frontmatter = `---\ndate: ${today}\n---\n\n`;
  } else if (isAdhoc) {
    dir = path.join(hubPath, 'threads', 'adhoc');
    threadId = `adhoc/${slug}`;
    frontmatter = `---\ncreated: ${new Date().toISOString()}\n---\n\n`;
  } else {
    // Default to adhoc
    dir = path.join(hubPath, 'threads', 'adhoc');
    threadId = `adhoc/${slug}`;
    frontmatter = `---\ncreated: ${new Date().toISOString()}\n---\n\n`;
  }
  
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  
  const filePath = path.join(dir, `${path.basename(threadId)}.md`);
  const content = `${frontmatter}# ${title}\n\n`;
  
  fs.writeFileSync(filePath, content);
  logAction(hubPath, 'thread.new', { id: threadId, title, result: 'ok' });
  ok(`Created thread: ${threadId}`);
}

// Show thread content
function threadShow(hubPath, name, threadId) {
  if (!threadId) {
    fail('Usage: cn thread show <id>');
    process.exit(1);
  }
  
  const filePath = threadIdToPath(hubPath, threadId);
  if (!fs.existsSync(filePath)) {
    fail(`Thread not found: ${threadId}`);
    process.exit(1);
  }
  
  const content = fs.readFileSync(filePath, 'utf8');
  console.log(content);
}

// Reply to thread
function threadReply(hubPath, name, threadId, message) {
  if (!threadId || !message) {
    fail('Usage: cn thread reply <id> <message>');
    process.exit(1);
  }
  
  const filePath = threadIdToPath(hubPath, threadId);
  if (!fs.existsSync(filePath)) {
    fail(`Thread not found: ${threadId}`);
    process.exit(1);
  }
  
  // Interpret escape sequences
  message = message.replace(/\\n/g, '\n').replace(/\\t/g, '\t');
  
  const timestamp = new Date().toISOString();
  const reply = `\n\n## Reply (${timestamp})\n\n${message}`;
  
  fs.appendFileSync(filePath, reply);
  logAction(hubPath, 'thread.reply', { id: threadId, bytes: message.length, result: 'ok' });
  ok(`Replied to: ${threadId}`);
}

// Close/archive thread
function threadClose(hubPath, name, threadId) {
  if (!threadId) {
    fail('Usage: cn thread close <id>');
    process.exit(1);
  }
  
  const filePath = threadIdToPath(hubPath, threadId);
  if (!fs.existsSync(filePath)) {
    fail(`Thread not found: ${threadId}`);
    process.exit(1);
  }
  
  const archivedDir = path.join(hubPath, 'threads', 'archived');
  if (!fs.existsSync(archivedDir)) {
    fs.mkdirSync(archivedDir, { recursive: true });
  }
  
  const fileName = path.basename(filePath);
  const archivedPath = path.join(archivedDir, fileName);
  
  // Add closed timestamp to frontmatter
  let content = fs.readFileSync(filePath, 'utf8');
  content = updateFrontmatter(content, { closed: new Date().toISOString() });
  
  fs.writeFileSync(archivedPath, content);
  fs.unlinkSync(filePath);
  
  logAction(hubPath, 'thread.close', { id: threadId, result: 'ok' });
  ok(`Closed thread: ${threadId} → archived`);
}

// Fetch inbound threads
function threadFetch(hubPath, name) {
  runInbox('check', hubPath, name);
  runInbox('process', hubPath, name);
}

// Send outbound threads
function threadSend(hubPath, name) {
  runOutbox('flush', hubPath, name);
}

// Convert thread ID to file path
function threadIdToPath(hubPath, threadId) {
  // threadId format: "inbox/pi-clp" or "daily/20260205"
  const parts = threadId.split('/');
  if (parts.length !== 2) {
    return path.join(hubPath, 'threads', threadId + '.md');
  }
  return path.join(hubPath, 'threads', parts[0], parts[1] + '.md');
}

// Parse YAML frontmatter
function parseFrontmatter(content) {
  const match = content.match(/^---\n([\s\S]*?)\n---/);
  if (!match) return {};
  const yaml = match[1];
  const meta = {};
  yaml.split('\n').forEach(line => {
    const [key, ...rest] = line.split(':');
    if (key && rest.length) {
      meta[key.trim().toLowerCase()] = rest.join(':').trim();
    }
  });
  return meta;
}

// Update frontmatter field
function updateFrontmatter(content, updates) {
  const match = content.match(/^---\n([\s\S]*?)\n---/);
  if (!match) {
    // No frontmatter, add it
    const lines = Object.entries(updates).map(([k, v]) => `${k}: ${v}`).join('\n');
    return `---\n${lines}\n---\n\n${content}`;
  }
  let yaml = match[1];
  for (const [key, val] of Object.entries(updates)) {
    const regex = new RegExp(`^${key}:.*$`, 'm');
    if (regex.test(yaml)) {
      yaml = yaml.replace(regex, `${key}: ${val}`);
    } else {
      yaml += `\n${key}: ${val}`;
    }
  }
  return content.replace(/^---\n[\s\S]*?\n---/, `---\n${yaml}\n---`);
}

// Parse outbox.md table
function parseOutbox(content) {
  const items = [];
  const lines = content.split('\n');
  let inTable = false;
  
  for (const line of lines) {
    if (line.startsWith('| To')) {
      inTable = true;
      continue;
    }
    if (line.startsWith('|--')) continue;
    if (!inTable || !line.startsWith('|')) continue;
    
    const cols = line.split('|').map(c => c.trim()).filter(c => c);
    if (cols.length >= 3) {
      items.push({
        to: cols[0],
        thread: cols[1],
        status: cols[2] || 'pending',
        sent: cols[3] || null
      });
    }
  }
  return items;
}

// Write outbox.md
function writeOutbox(outboxPath, items) {
  let content = `# Outbox

Agent writes pending sends here. cn reads and executes.

| To | Thread | Status | Sent |
|----|--------|--------|------|
`;
  for (const item of items) {
    content += `| ${item.to} | ${item.thread} | ${item.status} | ${item.sent || '—'} |\n`;
  }
  fs.writeFileSync(outboxPath, content);
}

// Parse peers.md
function parsePeers(content) {
  const peers = {};
  // Match each peer block
  const blocks = content.split(/(?=- name:)/);
  for (const block of blocks) {
    const nameMatch = block.match(/- name:\s*(\S+)/);
    if (!nameMatch) continue;
    const name = nameMatch[1];
    const hubMatch = block.match(/hub:\s*(\S+)/);
    const cloneMatch = block.match(/clone:\s*(\S+)/);
    peers[name] = { 
      name, 
      hub: hubMatch ? hubMatch[1] : null,
      clone: cloneMatch ? cloneMatch[1] : null
    };
  }
  return peers;
}

// Doctor command
function doctor(hubPath) {
  console.log(`cn v${VERSION}`);
  info(`Checking health...`);
  console.log('');
  
  let checks = [];
  let warnings = [];
  
  // Git
  try {
    const gitVersion = execSync('git --version', { encoding: 'utf8' }).trim();
    checks.push({ name: 'git', ok: true, val: gitVersion.replace('git version ', '') });
  } catch {
    checks.push({ name: 'git', ok: false, val: 'not installed' });
  }
  
  // Git config
  try {
    const userName = execSync('git config user.name', { encoding: 'utf8' }).trim();
    checks.push({ name: 'git user.name', ok: true, val: userName });
  } catch {
    checks.push({ name: 'git user.name', ok: false, val: 'not set' });
  }
  
  try {
    const userEmail = execSync('git config user.email', { encoding: 'utf8' }).trim();
    checks.push({ name: 'git user.email', ok: true, val: userEmail });
  } catch {
    checks.push({ name: 'git user.email', ok: false, val: 'not set' });
  }
  
  // Hub directory
  checks.push({ name: 'hub directory', ok: fs.existsSync(hubPath), val: fs.existsSync(hubPath) ? 'exists' : 'not found' });
  
  // .cn/config.json
  const configPath = path.join(hubPath, '.cn', 'config.json');
  checks.push({ name: '.cn/config.json', ok: fs.existsSync(configPath), val: fs.existsSync(configPath) ? 'exists' : 'missing' });
  
  // spec/SOUL.md
  const soulPath = path.join(hubPath, 'spec', 'SOUL.md');
  if (fs.existsSync(soulPath)) {
    checks.push({ name: 'spec/SOUL.md', ok: true, val: 'exists' });
  } else {
    warnings.push({ name: 'spec/SOUL.md', val: 'missing (optional)' });
  }
  
  // state/peers.md
  const peersPath = path.join(hubPath, 'state', 'peers.md');
  if (fs.existsSync(peersPath)) {
    const content = fs.readFileSync(peersPath, 'utf8');
    const peerCount = (content.match(/- name:/g) || []).length;
    checks.push({ name: 'state/peers.md', ok: true, val: `${peerCount} peer(s)` });
  } else {
    checks.push({ name: 'state/peers.md', ok: false, val: 'missing' });
  }
  
  // origin remote
  try {
    execSync('git remote get-url origin', { cwd: hubPath, encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] });
    checks.push({ name: 'origin remote', ok: true, val: 'configured' });
  } catch {
    checks.push({ name: 'origin remote', ok: false, val: 'not configured' });
  }
  
  // inbox status
  try {
    const result = execSync(`node ${path.join(__dirname, '..', 'dist', 'inbox.js')} check ${hubPath} ${deriveName(hubPath)} 2>&1`, { encoding: 'utf8' });
    const inboundMatch = result.match(/(\d+) inbound/);
    if (inboundMatch) {
      const count = parseInt(inboundMatch[1]);
      if (count > 0) {
        warnings.push({ name: 'inbox', val: `${count} pending` });
      } else {
        checks.push({ name: 'inbox', ok: true, val: 'clear' });
      }
    } else if (result.includes('All clear')) {
      checks.push({ name: 'inbox', ok: true, val: 'clear' });
    }
  } catch {
    warnings.push({ name: 'inbox', val: 'check failed' });
  }
  
  // Print checks
  const width = 22;
  checks.forEach(({ name, ok: isOk, val }) => {
    const dots = '.'.repeat(Math.max(1, width - name.length));
    const status = isOk 
      ? `${c.green}✓ ${val}${c.reset}`
      : `${c.red}✗ ${val}${c.reset}`;
    console.log(`${name}${dots} ${status}`);
  });
  
  // Print warnings
  warnings.forEach(({ name, val }) => {
    const dots = '.'.repeat(Math.max(1, width - name.length));
    console.log(`${name}${dots} ${c.yellow}⚠ ${val}${c.reset}`);
  });
  
  console.log('');
  const fails = checks.filter(c => !c.ok).length;
  const warns = warnings.length;
  
  if (fails === 0) {
    ok('All critical checks passed.');
  } else {
    fail(`${fails} issue(s) found.`);
  }
  
  console.log(`${c.dim}[status] ok=${checks.filter(c=>c.ok).length} warn=${warns} fail=${fails} version=${VERSION}${c.reset}`);
  process.exit(fails > 0 ? 1 : 0);
}

// Status command
function status(hubPath, name) {
  info(`cn hub: ${name}`);
  console.log('');
  console.log(`hub..................... ${c.green}✓${c.reset}`);
  console.log(`name.................... ${c.green}✓ ${name}${c.reset}`);
  console.log(`path.................... ${c.green}✓ ${hubPath}${c.reset}`);
  console.log('');
  console.log(`${c.dim}[status] ok version=${VERSION}${c.reset}`);
}

// Main
const args = process.argv.slice(2);
if (args.length === 0 || args[0] === '--help' || args[0] === '-h') {
  console.log(HELP);
  process.exit(0);
}

if (args[0] === '--version' || args[0] === '-V') {
  console.log(`cn ${VERSION}`);
  process.exit(0);
}

const command = expandAlias(args[0]);
const subArgs = args.slice(1);

// Commands that don't need hub
if (command === 'init') {
  warn('cn init not yet implemented');
  process.exit(1);
}

if (command === 'update') {
  // Check if already on latest
  try {
    const latest = execSync('npm view cnagent version', { encoding: 'utf8' }).trim();
    if (VERSION === latest) {
      ok(`Already up to date (v${VERSION})`);
      // Still write runtime.md if in a hub
      writeRuntimeMd(findHubPath(), latest);
      process.exit(0);
    }
    info(`Updating cnagent v${VERSION} → v${latest}...`);
    execSync('npm install -g cnagent@latest', { stdio: 'inherit' });
    ok(`Updated to v${latest}`);
    // Write runtime.md if in a hub
    writeRuntimeMd(findHubPath(), latest);
  } catch (e) {
    fail('Update failed. Try: npm install -g cnagent@latest');
    process.exit(1);
  }
  process.exit(0);
}

// Write state/runtime.md after update
function writeRuntimeMd(hubPath, cnVersion) {
  if (!hubPath) return; // Not in a hub, skip
  
  const runtimePath = path.join(hubPath, 'state', 'runtime.md');
  const stateDir = path.join(hubPath, 'state');
  
  // Ensure state/ exists
  if (!fs.existsSync(stateDir)) {
    fs.mkdirSync(stateDir, { recursive: true });
  }
  
  // Get template version and commit
  let templateVersion = 'unknown';
  let cnCommit = 'unknown';
  const cnDir = path.join(__dirname, '..');
  try {
    const pkgPath = path.join(cnDir, 'package.json');
    if (fs.existsSync(pkgPath)) {
      const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
      templateVersion = pkg.version || 'unknown';
    }
    cnCommit = execSync('git rev-parse --short HEAD 2>/dev/null', { 
      encoding: 'utf8', 
      cwd: cnDir 
    }).trim() || 'unknown';
  } catch {}
  
  // Gather runtime info (agent-relevant only)
  const hubName = deriveName(hubPath);
  
  // Hub commit hash
  let hubCommit = 'unknown';
  try {
    hubCommit = execSync('git rev-parse --short HEAD 2>/dev/null', { 
      encoding: 'utf8', 
      cwd: hubPath 
    }).trim() || 'unknown';
  } catch {}
  
  // OpenClaw version
  let openclawVersion = 'not installed';
  try {
    openclawVersion = execSync('openclaw --version 2>/dev/null', { encoding: 'utf8' }).trim();
  } catch {}
  
  let peerCount = 0;
  try {
    const peersPath = path.join(hubPath, 'state', 'peers.md');
    if (fs.existsSync(peersPath)) {
      const content = fs.readFileSync(peersPath, 'utf8');
      peerCount = (content.match(/- name:/g) || []).length;
    }
  } catch {}

  const content = `# Runtime State

Auto-generated by \`cn update\`. Do not edit manually.

\`\`\`yaml
session_start: ${new Date().toISOString()}
cn_version: ${cnVersion}
cn_commit: ${cnCommit}
template_version: ${templateVersion}
openclaw_version: ${openclawVersion}
hub_name: ${hubName}
hub_commit: ${hubCommit}
peer_count: ${peerCount}
\`\`\`
`;

  fs.writeFileSync(runtimePath, content);
  info(`Wrote ${runtimePath}`);
}

// Find hub
const hubPath = findHubPath();
if (!hubPath) {
  fail('Not in a cn hub.');
  console.log('');
  console.log('Either:');
  console.log(`  1) ${cmd('cd')} into an existing hub (cn-sigma, cn-pi, etc.)`);
  console.log(`  2) ${cmd('cn init <name>')} to create a new one`);
  process.exit(1);
}

const name = deriveName(hubPath);

switch (command) {
  case 'status':
    status(hubPath, name);
    break;
    
  case 'doctor':
    doctor(hubPath);
    break;
    
  case 'thread':
    runThread(hubPath, name, subArgs);
    break;
    
  case 'inbox':
    const inboxSubCmd = subArgs[0] || 'check';
    if (!['check', 'process', 'flush'].includes(inboxSubCmd)) {
      fail(`Unknown inbox command: ${inboxSubCmd}`);
      process.exit(1);
    }
    runInbox(inboxSubCmd, hubPath, name);
    break;
    
  case 'outbox':
    const outboxSubCmd = subArgs[0] || 'check';
    if (!['check', 'flush'].includes(outboxSubCmd)) {
      fail(`Unknown outbox command: ${outboxSubCmd}`);
      process.exit(1);
    }
    runOutbox(outboxSubCmd, hubPath, name);
    break;
    
  case 'sync':
    info('Running sync...');
    runInbox('check', hubPath, name);
    runInbox('process', hubPath, name);
    runInbox('flush', hubPath, name);
    runOutbox('flush', hubPath, name);
    ok('Sync complete');
    break;
    
  case 'commit':
    runCommit(hubPath, name, subArgs.join(' '));
    break;
    
  case 'push':
    runPush(hubPath, name);
    break;
    
  case 'save':
    // Convenience: commit + push
    runCommit(hubPath, name, subArgs.join(' ') || `${name}: save ${new Date().toISOString().slice(0, 16)}`);
    runPush(hubPath, name);
    break;
    
  case 'write':
    runWrite(hubPath, subArgs[0], subArgs.slice(1).join(' '));
    break;
    
  case 'append':
    runAppend(hubPath, subArgs[0], subArgs.slice(1).join(' '));
    break;
    
  case 'mkdir':
    runMkdir(hubPath, subArgs[0]);
    break;
    
  case 'rm':
    runRm(hubPath, subArgs[0]);
    break;
    
  default:
    fail(`Unknown command: ${command}`);
    console.log(`Run ${cmd('cn --help')} for usage.`);
    process.exit(1);
}
