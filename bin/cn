#!/usr/bin/env node

/**
 * cn - Coherent Network agent CLI
 * 
 * This is a thin wrapper that routes to the appropriate tool.
 * OCaml source in tools/src/cn/, bundled JS in dist/cn.js
 */

const { execSync, spawn } = require('child_process');
const path = require('path');
const fs = require('fs');

const VERSION = '2.0.4';

// Colors (respects NO_COLOR)
const noColor = process.env.NO_COLOR !== undefined;
const c = {
  reset: noColor ? '' : '\x1b[0m',
  green: noColor ? '' : '\x1b[32m',
  red: noColor ? '' : '\x1b[31m',
  yellow: noColor ? '' : '\x1b[33m',
  cyan: noColor ? '' : '\x1b[36m',
  magenta: noColor ? '' : '\x1b[35m',
  dim: noColor ? '' : '\x1b[2m',
};

const ok = (msg) => console.log(`${c.green}✓ ${msg}${c.reset}`);
const fail = (msg) => console.log(`${c.red}✗ ${msg}${c.reset}`);
const info = (msg) => console.log(`${c.cyan}${msg}${c.reset}`);
const warn = (msg) => console.log(`${c.yellow}⚠ ${msg}${c.reset}`);
const cmd = (msg) => `${c.magenta}${msg}${c.reset}`;

const HELP = `cn - Coherent Network agent CLI

Usage: cn <command> [options]

Commands:
  init [name]         Create new hub
  status              Show hub state
  inbox               Manage inbound messages
    check             List inbound branches
    process           Materialize as threads
    flush             Execute decisions
  peer                Manage peers
  doctor              Check system health
  update              Update cn to latest version

Aliases:
  i = inbox, s = status, d = doctor

Flags:
  --help, -h          Show help
  --version, -V       Show version

Examples:
  cn init sigma       Create hub named 'sigma'
  cn inbox check      List inbound branches
  cn doctor           Check system health
`;

// Expand aliases
const aliases = { i: 'inbox', s: 'status', d: 'doctor', p: 'peer', t: 'thread' };
const expandAlias = (cmd) => aliases[cmd] || cmd;

// Find hub path
function findHubPath() {
  let dir = process.cwd();
  while (dir !== '/') {
    if (fs.existsSync(path.join(dir, '.cn', 'config.json'))) {
      return dir;
    }
    // Also check for cn-* pattern with state/peers.md
    if (fs.existsSync(path.join(dir, 'state', 'peers.md'))) {
      return dir;
    }
    dir = path.dirname(dir);
  }
  return null;
}

// Derive name from path
function deriveName(hubPath) {
  const base = path.basename(hubPath);
  return base.startsWith('cn-') ? base.slice(3) : base;
}

// Run inbox tool
function runInbox(subCmd, hubPath, name) {
  const inboxJs = path.join(__dirname, '..', 'dist', 'inbox.js');
  if (!fs.existsSync(inboxJs)) {
    fail('inbox.js not found. Run from cn-agent directory or install globally.');
    process.exit(1);
  }
  const args = [inboxJs, subCmd, hubPath, name];
  const result = spawn('node', args, { stdio: 'inherit' });
  result.on('close', (code) => process.exit(code));
}

// Doctor command
function doctor(hubPath) {
  console.log(`cn v${VERSION}`);
  info(`Checking health...`);
  console.log('');
  
  let checks = [];
  let warnings = [];
  
  // Git
  try {
    const gitVersion = execSync('git --version', { encoding: 'utf8' }).trim();
    checks.push({ name: 'git', ok: true, val: gitVersion.replace('git version ', '') });
  } catch {
    checks.push({ name: 'git', ok: false, val: 'not installed' });
  }
  
  // Git config
  try {
    const userName = execSync('git config user.name', { encoding: 'utf8' }).trim();
    checks.push({ name: 'git user.name', ok: true, val: userName });
  } catch {
    checks.push({ name: 'git user.name', ok: false, val: 'not set' });
  }
  
  try {
    const userEmail = execSync('git config user.email', { encoding: 'utf8' }).trim();
    checks.push({ name: 'git user.email', ok: true, val: userEmail });
  } catch {
    checks.push({ name: 'git user.email', ok: false, val: 'not set' });
  }
  
  // Hub directory
  checks.push({ name: 'hub directory', ok: fs.existsSync(hubPath), val: fs.existsSync(hubPath) ? 'exists' : 'not found' });
  
  // .cn/config.json
  const configPath = path.join(hubPath, '.cn', 'config.json');
  checks.push({ name: '.cn/config.json', ok: fs.existsSync(configPath), val: fs.existsSync(configPath) ? 'exists' : 'missing' });
  
  // spec/SOUL.md
  const soulPath = path.join(hubPath, 'spec', 'SOUL.md');
  if (fs.existsSync(soulPath)) {
    checks.push({ name: 'spec/SOUL.md', ok: true, val: 'exists' });
  } else {
    warnings.push({ name: 'spec/SOUL.md', val: 'missing (optional)' });
  }
  
  // state/peers.md
  const peersPath = path.join(hubPath, 'state', 'peers.md');
  if (fs.existsSync(peersPath)) {
    const content = fs.readFileSync(peersPath, 'utf8');
    const peerCount = (content.match(/- name:/g) || []).length;
    checks.push({ name: 'state/peers.md', ok: true, val: `${peerCount} peer(s)` });
  } else {
    checks.push({ name: 'state/peers.md', ok: false, val: 'missing' });
  }
  
  // origin remote
  try {
    execSync('git remote get-url origin', { cwd: hubPath, encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] });
    checks.push({ name: 'origin remote', ok: true, val: 'configured' });
  } catch {
    checks.push({ name: 'origin remote', ok: false, val: 'not configured' });
  }
  
  // inbox status
  try {
    const result = execSync(`node ${path.join(__dirname, '..', 'dist', 'inbox.js')} check ${hubPath} ${deriveName(hubPath)} 2>&1`, { encoding: 'utf8' });
    const inboundMatch = result.match(/(\d+) inbound/);
    if (inboundMatch) {
      const count = parseInt(inboundMatch[1]);
      if (count > 0) {
        warnings.push({ name: 'inbox', val: `${count} pending` });
      } else {
        checks.push({ name: 'inbox', ok: true, val: 'clear' });
      }
    } else if (result.includes('All clear')) {
      checks.push({ name: 'inbox', ok: true, val: 'clear' });
    }
  } catch {
    warnings.push({ name: 'inbox', val: 'check failed' });
  }
  
  // Print checks
  const width = 22;
  checks.forEach(({ name, ok: isOk, val }) => {
    const dots = '.'.repeat(Math.max(1, width - name.length));
    const status = isOk 
      ? `${c.green}✓ ${val}${c.reset}`
      : `${c.red}✗ ${val}${c.reset}`;
    console.log(`${name}${dots} ${status}`);
  });
  
  // Print warnings
  warnings.forEach(({ name, val }) => {
    const dots = '.'.repeat(Math.max(1, width - name.length));
    console.log(`${name}${dots} ${c.yellow}⚠ ${val}${c.reset}`);
  });
  
  console.log('');
  const fails = checks.filter(c => !c.ok).length;
  const warns = warnings.length;
  
  if (fails === 0) {
    ok('All critical checks passed.');
  } else {
    fail(`${fails} issue(s) found.`);
  }
  
  console.log(`${c.dim}[status] ok=${checks.filter(c=>c.ok).length} warn=${warns} fail=${fails} version=${VERSION}${c.reset}`);
  process.exit(fails > 0 ? 1 : 0);
}

// Status command
function status(hubPath, name) {
  info(`cn hub: ${name}`);
  console.log('');
  console.log(`hub..................... ${c.green}✓${c.reset}`);
  console.log(`name.................... ${c.green}✓ ${name}${c.reset}`);
  console.log(`path.................... ${c.green}✓ ${hubPath}${c.reset}`);
  console.log('');
  console.log(`${c.dim}[status] ok version=${VERSION}${c.reset}`);
}

// Main
const args = process.argv.slice(2);
if (args.length === 0 || args[0] === '--help' || args[0] === '-h') {
  console.log(HELP);
  process.exit(0);
}

if (args[0] === '--version' || args[0] === '-V') {
  console.log(`cn ${VERSION}`);
  process.exit(0);
}

const command = expandAlias(args[0]);
const subArgs = args.slice(1);

// Commands that don't need hub
if (command === 'init') {
  warn('cn init not yet implemented');
  process.exit(1);
}

if (command === 'update') {
  info('Updating cnagent...');
  try {
    execSync('npm install -g cnagent@latest', { stdio: 'inherit' });
    ok('Updated to latest version.');
    execSync('cn --version', { stdio: 'inherit' });
  } catch (e) {
    fail('Update failed. Try: npm install -g cnagent@latest');
    process.exit(1);
  }
  process.exit(0);
}

// Find hub
const hubPath = findHubPath();
if (!hubPath) {
  fail('Not in a cn hub.');
  console.log('');
  console.log('Either:');
  console.log(`  1) ${cmd('cd')} into an existing hub (cn-sigma, cn-pi, etc.)`);
  console.log(`  2) ${cmd('cn init <name>')} to create a new one`);
  process.exit(1);
}

const name = deriveName(hubPath);

switch (command) {
  case 'status':
    status(hubPath, name);
    break;
    
  case 'doctor':
    doctor(hubPath);
    break;
    
  case 'inbox':
    const subCmd = subArgs[0] || 'check';
    if (!['check', 'process', 'flush'].includes(subCmd)) {
      fail(`Unknown inbox command: ${subCmd}`);
      process.exit(1);
    }
    runInbox(subCmd, hubPath, name);
    break;
    
  default:
    fail(`Unknown command: ${command}`);
    console.log(`Run ${cmd('cn --help')} for usage.`);
    process.exit(1);
}
