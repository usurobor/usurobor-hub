#!/usr/bin/env node

/**
 * cn - Coherent Network agent CLI
 * 
 * This is a thin wrapper that routes to the appropriate tool.
 * OCaml source in tools/src/cn/, bundled JS in dist/cn.js
 */

const { execSync, spawn } = require('child_process');
const path = require('path');
const fs = require('fs');

const VERSION = '2.0.7';

// Colors (respects NO_COLOR)
const noColor = process.env.NO_COLOR !== undefined;
const c = {
  reset: noColor ? '' : '\x1b[0m',
  green: noColor ? '' : '\x1b[32m',
  red: noColor ? '' : '\x1b[31m',
  yellow: noColor ? '' : '\x1b[33m',
  cyan: noColor ? '' : '\x1b[36m',
  magenta: noColor ? '' : '\x1b[35m',
  dim: noColor ? '' : '\x1b[2m',
};

const ok = (msg) => console.log(`${c.green}✓ ${msg}${c.reset}`);
const fail = (msg) => console.log(`${c.red}✗ ${msg}${c.reset}`);
const info = (msg) => console.log(`${c.cyan}${msg}${c.reset}`);
const warn = (msg) => console.log(`${c.yellow}⚠ ${msg}${c.reset}`);
const cmd = (msg) => `${c.magenta}${msg}${c.reset}`;

const HELP = `cn - Coherent Network agent CLI

Usage: cn <command> [options]

Commands:
  init [name]         Create new hub
  status              Show hub state
  inbox               Manage inbound messages
    check             List inbound branches
    process           Materialize as threads
    flush             Execute decisions
  outbox              Manage outbound messages
    check             List pending sends
    flush             Push branches to peers
  sync                Run inbox check + outbox flush
  peer                Manage peers
  doctor              Check system health
  update              Update cn to latest version

Aliases:
  i = inbox, s = status, d = doctor

Flags:
  --help, -h          Show help
  --version, -V       Show version

Examples:
  cn init sigma       Create hub named 'sigma'
  cn inbox check      List inbound branches
  cn doctor           Check system health
`;

// Expand aliases
const aliases = { i: 'inbox', o: 'outbox', s: 'status', d: 'doctor', p: 'peer', t: 'thread' };
const expandAlias = (cmd) => aliases[cmd] || cmd;

// Find hub path
function findHubPath() {
  let dir = process.cwd();
  while (dir !== '/') {
    if (fs.existsSync(path.join(dir, '.cn', 'config.json'))) {
      return dir;
    }
    // Also check for cn-* pattern with state/peers.md
    if (fs.existsSync(path.join(dir, 'state', 'peers.md'))) {
      return dir;
    }
    dir = path.dirname(dir);
  }
  return null;
}

// Derive name from path
function deriveName(hubPath) {
  const base = path.basename(hubPath);
  return base.startsWith('cn-') ? base.slice(3) : base;
}

// Append-only action log
function logAction(hubPath, action, details = {}) {
  const logsDir = path.join(hubPath, 'logs');
  if (!fs.existsSync(logsDir)) {
    fs.mkdirSync(logsDir, { recursive: true });
  }
  const entry = {
    ts: new Date().toISOString(),
    action,
    ...details
  };
  fs.appendFileSync(
    path.join(logsDir, 'cn.log'),
    JSON.stringify(entry) + '\n'
  );
}

// Run inbox tool
function runInbox(subCmd, hubPath, name) {
  const inboxJs = path.join(__dirname, '..', 'dist', 'inbox.js');
  if (!fs.existsSync(inboxJs)) {
    fail('inbox.js not found. Run from cn-agent directory or install globally.');
    process.exit(1);
  }
  const args = [inboxJs, subCmd, hubPath, name];
  const result = spawn('node', args, { stdio: 'inherit' });
  result.on('close', (code) => process.exit(code));
}

// Run outbox commands (threads/outbox/ model)
function runOutbox(subCmd, hubPath, name) {
  const outboxDir = path.join(hubPath, 'threads', 'outbox');
  const sentDir = path.join(hubPath, 'threads', 'sent');
  const peersPath = path.join(hubPath, 'state', 'peers.md');
  
  // Ensure directories exist
  if (!fs.existsSync(outboxDir)) {
    fs.mkdirSync(outboxDir, { recursive: true });
  }
  if (!fs.existsSync(sentDir)) {
    fs.mkdirSync(sentDir, { recursive: true });
  }
  
  // Load peers
  let peers = {};
  if (fs.existsSync(peersPath)) {
    const peersContent = fs.readFileSync(peersPath, 'utf8');
    peers = parsePeers(peersContent);
  }
  
  // Scan outbox for threads
  const threads = fs.readdirSync(outboxDir)
    .filter(f => f.endsWith('.md'))
    .map(f => {
      const filePath = path.join(outboxDir, f);
      const content = fs.readFileSync(filePath, 'utf8');
      const meta = parseFrontmatter(content);
      return { file: f, path: filePath, content, meta };
    });
  
  if (subCmd === 'check') {
    if (threads.length === 0) {
      ok('Outbox clear');
      return;
    }
    warn(`${threads.length} pending send(s):`);
    threads.forEach(t => {
      const to = t.meta.to || '(no recipient)';
      console.log(`  → ${to}: ${t.file}`);
    });
    return;
  }
  
  if (subCmd === 'flush') {
    if (threads.length === 0) {
      ok('Outbox clear');
      return;
    }
    
    info(`Flushing ${threads.length} thread(s)...`);
    
    for (const t of threads) {
      const to = t.meta.to;
      if (!to) {
        logAction(hubPath, 'outbox.skip', { thread: t.file, reason: 'no recipient (to: field missing)' });
        warn(`Skipping ${t.file}: no 'to:' in frontmatter`);
        continue;
      }
      
      const peer = peers[to];
      if (!peer) {
        logAction(hubPath, 'outbox.skip', { thread: t.file, to, reason: 'unknown peer' });
        fail(`Unknown peer: ${to}`);
        continue;
      }
      
      if (!peer.clone) {
        logAction(hubPath, 'outbox.skip', { thread: t.file, to, reason: 'no clone path configured' });
        fail(`No clone path for peer: ${to}`);
        continue;
      }
      
      try {
        const threadName = path.basename(t.file, '.md');
        const branchName = `${name}/${threadName}`;
        
        // Actor model: push to PEER's repo (their clone)
        // 1. Ensure peer clone is on main and up to date
        execSync(`git checkout main 2>/dev/null || git checkout master`, { cwd: peer.clone, stdio: 'pipe' });
        execSync(`git pull --ff-only 2>/dev/null || true`, { cwd: peer.clone, stdio: 'pipe' });
        
        // 2. Create branch in peer's clone
        execSync(`git checkout -b ${branchName} 2>/dev/null || git checkout ${branchName}`, { cwd: peer.clone, stdio: 'pipe' });
        
        // 3. Copy thread to peer's threads/adhoc/ (standardized location)
        const peerThreadDir = path.join(peer.clone, 'threads', 'adhoc');
        if (!fs.existsSync(peerThreadDir)) {
          fs.mkdirSync(peerThreadDir, { recursive: true });
        }
        const peerThreadPath = path.join(peerThreadDir, t.file);
        fs.copyFileSync(t.path, peerThreadPath);
        
        // 4. Commit and push
        execSync(`git add "threads/adhoc/${t.file}"`, { cwd: peer.clone, stdio: 'pipe' });
        execSync(`git commit -m "${name}: ${threadName}"`, { cwd: peer.clone, stdio: 'pipe' });
        execSync(`git push -u origin ${branchName} -f`, { cwd: peer.clone, stdio: 'pipe' });
        
        // 5. Return to main
        execSync(`git checkout main 2>/dev/null || git checkout master`, { cwd: peer.clone, stdio: 'pipe' });
        
        // Move to sent/
        const sentPath = path.join(sentDir, t.file);
        const sentContent = updateFrontmatter(t.content, { sent: new Date().toISOString() });
        fs.writeFileSync(sentPath, sentContent);
        fs.unlinkSync(t.path);
        
        logAction(hubPath, 'outbox.send', { to, thread: t.file, branch: branchName, clone: peer.clone, result: 'ok' });
        ok(`Sent to ${to}: ${t.file}`);
      } catch (err) {
        logAction(hubPath, 'outbox.send', { to, thread: t.file, result: 'error', error: err.message });
        fail(`Failed to send ${t.file}: ${err.message}`);
        execSync(`git checkout main 2>/dev/null || true`, { cwd: hubPath, stdio: 'pipe' });
      }
    }
    
    ok('Outbox flush complete');
  }
}

// Parse YAML frontmatter
function parseFrontmatter(content) {
  const match = content.match(/^---\n([\s\S]*?)\n---/);
  if (!match) return {};
  const yaml = match[1];
  const meta = {};
  yaml.split('\n').forEach(line => {
    const [key, ...rest] = line.split(':');
    if (key && rest.length) {
      meta[key.trim().toLowerCase()] = rest.join(':').trim();
    }
  });
  return meta;
}

// Update frontmatter field
function updateFrontmatter(content, updates) {
  const match = content.match(/^---\n([\s\S]*?)\n---/);
  if (!match) {
    // No frontmatter, add it
    const lines = Object.entries(updates).map(([k, v]) => `${k}: ${v}`).join('\n');
    return `---\n${lines}\n---\n\n${content}`;
  }
  let yaml = match[1];
  for (const [key, val] of Object.entries(updates)) {
    const regex = new RegExp(`^${key}:.*$`, 'm');
    if (regex.test(yaml)) {
      yaml = yaml.replace(regex, `${key}: ${val}`);
    } else {
      yaml += `\n${key}: ${val}`;
    }
  }
  return content.replace(/^---\n[\s\S]*?\n---/, `---\n${yaml}\n---`);
}

// Parse outbox.md table
function parseOutbox(content) {
  const items = [];
  const lines = content.split('\n');
  let inTable = false;
  
  for (const line of lines) {
    if (line.startsWith('| To')) {
      inTable = true;
      continue;
    }
    if (line.startsWith('|--')) continue;
    if (!inTable || !line.startsWith('|')) continue;
    
    const cols = line.split('|').map(c => c.trim()).filter(c => c);
    if (cols.length >= 3) {
      items.push({
        to: cols[0],
        thread: cols[1],
        status: cols[2] || 'pending',
        sent: cols[3] || null
      });
    }
  }
  return items;
}

// Write outbox.md
function writeOutbox(outboxPath, items) {
  let content = `# Outbox

Agent writes pending sends here. cn reads and executes.

| To | Thread | Status | Sent |
|----|--------|--------|------|
`;
  for (const item of items) {
    content += `| ${item.to} | ${item.thread} | ${item.status} | ${item.sent || '—'} |\n`;
  }
  fs.writeFileSync(outboxPath, content);
}

// Parse peers.md
function parsePeers(content) {
  const peers = {};
  // Match each peer block
  const blocks = content.split(/(?=- name:)/);
  for (const block of blocks) {
    const nameMatch = block.match(/- name:\s*(\S+)/);
    if (!nameMatch) continue;
    const name = nameMatch[1];
    const hubMatch = block.match(/hub:\s*(\S+)/);
    const cloneMatch = block.match(/clone:\s*(\S+)/);
    peers[name] = { 
      name, 
      hub: hubMatch ? hubMatch[1] : null,
      clone: cloneMatch ? cloneMatch[1] : null
    };
  }
  return peers;
}

// Doctor command
function doctor(hubPath) {
  console.log(`cn v${VERSION}`);
  info(`Checking health...`);
  console.log('');
  
  let checks = [];
  let warnings = [];
  
  // Git
  try {
    const gitVersion = execSync('git --version', { encoding: 'utf8' }).trim();
    checks.push({ name: 'git', ok: true, val: gitVersion.replace('git version ', '') });
  } catch {
    checks.push({ name: 'git', ok: false, val: 'not installed' });
  }
  
  // Git config
  try {
    const userName = execSync('git config user.name', { encoding: 'utf8' }).trim();
    checks.push({ name: 'git user.name', ok: true, val: userName });
  } catch {
    checks.push({ name: 'git user.name', ok: false, val: 'not set' });
  }
  
  try {
    const userEmail = execSync('git config user.email', { encoding: 'utf8' }).trim();
    checks.push({ name: 'git user.email', ok: true, val: userEmail });
  } catch {
    checks.push({ name: 'git user.email', ok: false, val: 'not set' });
  }
  
  // Hub directory
  checks.push({ name: 'hub directory', ok: fs.existsSync(hubPath), val: fs.existsSync(hubPath) ? 'exists' : 'not found' });
  
  // .cn/config.json
  const configPath = path.join(hubPath, '.cn', 'config.json');
  checks.push({ name: '.cn/config.json', ok: fs.existsSync(configPath), val: fs.existsSync(configPath) ? 'exists' : 'missing' });
  
  // spec/SOUL.md
  const soulPath = path.join(hubPath, 'spec', 'SOUL.md');
  if (fs.existsSync(soulPath)) {
    checks.push({ name: 'spec/SOUL.md', ok: true, val: 'exists' });
  } else {
    warnings.push({ name: 'spec/SOUL.md', val: 'missing (optional)' });
  }
  
  // state/peers.md
  const peersPath = path.join(hubPath, 'state', 'peers.md');
  if (fs.existsSync(peersPath)) {
    const content = fs.readFileSync(peersPath, 'utf8');
    const peerCount = (content.match(/- name:/g) || []).length;
    checks.push({ name: 'state/peers.md', ok: true, val: `${peerCount} peer(s)` });
  } else {
    checks.push({ name: 'state/peers.md', ok: false, val: 'missing' });
  }
  
  // origin remote
  try {
    execSync('git remote get-url origin', { cwd: hubPath, encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] });
    checks.push({ name: 'origin remote', ok: true, val: 'configured' });
  } catch {
    checks.push({ name: 'origin remote', ok: false, val: 'not configured' });
  }
  
  // inbox status
  try {
    const result = execSync(`node ${path.join(__dirname, '..', 'dist', 'inbox.js')} check ${hubPath} ${deriveName(hubPath)} 2>&1`, { encoding: 'utf8' });
    const inboundMatch = result.match(/(\d+) inbound/);
    if (inboundMatch) {
      const count = parseInt(inboundMatch[1]);
      if (count > 0) {
        warnings.push({ name: 'inbox', val: `${count} pending` });
      } else {
        checks.push({ name: 'inbox', ok: true, val: 'clear' });
      }
    } else if (result.includes('All clear')) {
      checks.push({ name: 'inbox', ok: true, val: 'clear' });
    }
  } catch {
    warnings.push({ name: 'inbox', val: 'check failed' });
  }
  
  // Print checks
  const width = 22;
  checks.forEach(({ name, ok: isOk, val }) => {
    const dots = '.'.repeat(Math.max(1, width - name.length));
    const status = isOk 
      ? `${c.green}✓ ${val}${c.reset}`
      : `${c.red}✗ ${val}${c.reset}`;
    console.log(`${name}${dots} ${status}`);
  });
  
  // Print warnings
  warnings.forEach(({ name, val }) => {
    const dots = '.'.repeat(Math.max(1, width - name.length));
    console.log(`${name}${dots} ${c.yellow}⚠ ${val}${c.reset}`);
  });
  
  console.log('');
  const fails = checks.filter(c => !c.ok).length;
  const warns = warnings.length;
  
  if (fails === 0) {
    ok('All critical checks passed.');
  } else {
    fail(`${fails} issue(s) found.`);
  }
  
  console.log(`${c.dim}[status] ok=${checks.filter(c=>c.ok).length} warn=${warns} fail=${fails} version=${VERSION}${c.reset}`);
  process.exit(fails > 0 ? 1 : 0);
}

// Status command
function status(hubPath, name) {
  info(`cn hub: ${name}`);
  console.log('');
  console.log(`hub..................... ${c.green}✓${c.reset}`);
  console.log(`name.................... ${c.green}✓ ${name}${c.reset}`);
  console.log(`path.................... ${c.green}✓ ${hubPath}${c.reset}`);
  console.log('');
  console.log(`${c.dim}[status] ok version=${VERSION}${c.reset}`);
}

// Main
const args = process.argv.slice(2);
if (args.length === 0 || args[0] === '--help' || args[0] === '-h') {
  console.log(HELP);
  process.exit(0);
}

if (args[0] === '--version' || args[0] === '-V') {
  console.log(`cn ${VERSION}`);
  process.exit(0);
}

const command = expandAlias(args[0]);
const subArgs = args.slice(1);

// Commands that don't need hub
if (command === 'init') {
  warn('cn init not yet implemented');
  process.exit(1);
}

if (command === 'update') {
  // Check if already on latest
  try {
    const latest = execSync('npm view cnagent version', { encoding: 'utf8' }).trim();
    if (VERSION === latest) {
      ok(`Already up to date (v${VERSION})`);
      // Still write runtime.md if in a hub
      writeRuntimeMd(findHubPath(), latest);
      process.exit(0);
    }
    info(`Updating cnagent v${VERSION} → v${latest}...`);
    execSync('npm install -g cnagent@latest', { stdio: 'inherit' });
    ok(`Updated to v${latest}`);
    // Write runtime.md if in a hub
    writeRuntimeMd(findHubPath(), latest);
  } catch (e) {
    fail('Update failed. Try: npm install -g cnagent@latest');
    process.exit(1);
  }
  process.exit(0);
}

// Write state/runtime.md after update
function writeRuntimeMd(hubPath, cnVersion) {
  if (!hubPath) return; // Not in a hub, skip
  
  const runtimePath = path.join(hubPath, 'state', 'runtime.md');
  const stateDir = path.join(hubPath, 'state');
  
  // Ensure state/ exists
  if (!fs.existsSync(stateDir)) {
    fs.mkdirSync(stateDir, { recursive: true });
  }
  
  // Get template version and commit
  let templateVersion = 'unknown';
  let cnCommit = 'unknown';
  const cnDir = path.join(__dirname, '..');
  try {
    const pkgPath = path.join(cnDir, 'package.json');
    if (fs.existsSync(pkgPath)) {
      const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
      templateVersion = pkg.version || 'unknown';
    }
    cnCommit = execSync('git rev-parse --short HEAD 2>/dev/null', { 
      encoding: 'utf8', 
      cwd: cnDir 
    }).trim() || 'unknown';
  } catch {}
  
  // Gather runtime info (agent-relevant only)
  const hubName = deriveName(hubPath);
  
  // Hub commit hash
  let hubCommit = 'unknown';
  try {
    hubCommit = execSync('git rev-parse --short HEAD 2>/dev/null', { 
      encoding: 'utf8', 
      cwd: hubPath 
    }).trim() || 'unknown';
  } catch {}
  
  // OpenClaw version
  let openclawVersion = 'not installed';
  try {
    openclawVersion = execSync('openclaw --version 2>/dev/null', { encoding: 'utf8' }).trim();
  } catch {}
  
  let peerCount = 0;
  try {
    const peersPath = path.join(hubPath, 'state', 'peers.md');
    if (fs.existsSync(peersPath)) {
      const content = fs.readFileSync(peersPath, 'utf8');
      peerCount = (content.match(/- name:/g) || []).length;
    }
  } catch {}

  const content = `# Runtime State

Auto-generated by \`cn update\`. Do not edit manually.

\`\`\`yaml
session_start: ${new Date().toISOString()}
cn_version: ${cnVersion}
cn_commit: ${cnCommit}
template_version: ${templateVersion}
openclaw_version: ${openclawVersion}
hub_name: ${hubName}
hub_commit: ${hubCommit}
peer_count: ${peerCount}
\`\`\`
`;

  fs.writeFileSync(runtimePath, content);
  info(`Wrote ${runtimePath}`);
}

// Find hub
const hubPath = findHubPath();
if (!hubPath) {
  fail('Not in a cn hub.');
  console.log('');
  console.log('Either:');
  console.log(`  1) ${cmd('cd')} into an existing hub (cn-sigma, cn-pi, etc.)`);
  console.log(`  2) ${cmd('cn init <name>')} to create a new one`);
  process.exit(1);
}

const name = deriveName(hubPath);

switch (command) {
  case 'status':
    status(hubPath, name);
    break;
    
  case 'doctor':
    doctor(hubPath);
    break;
    
  case 'inbox':
    const inboxSubCmd = subArgs[0] || 'check';
    if (!['check', 'process', 'flush'].includes(inboxSubCmd)) {
      fail(`Unknown inbox command: ${inboxSubCmd}`);
      process.exit(1);
    }
    runInbox(inboxSubCmd, hubPath, name);
    break;
    
  case 'outbox':
    const outboxSubCmd = subArgs[0] || 'check';
    if (!['check', 'flush'].includes(outboxSubCmd)) {
      fail(`Unknown outbox command: ${outboxSubCmd}`);
      process.exit(1);
    }
    runOutbox(outboxSubCmd, hubPath, name);
    break;
    
  case 'sync':
    info('Running sync...');
    runInbox('check', hubPath, name);
    runOutbox('flush', hubPath, name);
    ok('Sync complete');
    break;
    
  default:
    fail(`Unknown command: ${command}`);
    console.log(`Run ${cmd('cn --help')} for usage.`);
    process.exit(1);
}
