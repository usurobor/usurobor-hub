(** cn_system.ml — System setup, updates, and hub initialization

    System lifecycle: status, doctor, setup, update, sync, init.
    Merged from: cn_system + cn_init in the 14-module plan. *)

open Cn_lib

(* === Runtime === *)

let update_runtime hub_path =
  let runtime_path = Cn_ffi.Path.join hub_path "state/runtime.md" in
  let cn_ver = match Cn_ffi.Child_process.exec "cn --version 2>/dev/null" with
    | Some v -> String.trim v |> fun s ->
        (match String.split_on_char ' ' s with
         | _ :: v :: _ -> v
         | _ -> "unknown")
    | None -> "unknown"
  in
  let oc_ver = match Cn_ffi.Child_process.exec "openclaw --version 2>/dev/null" with
    | Some v -> String.trim v
    | None -> "unknown"
  in
  let hub_name = derive_name hub_path in
  let hub_commit = match Cn_ffi.Child_process.exec_in ~cwd:hub_path "git rev-parse --short HEAD 2>/dev/null" with
    | Some c -> String.trim c
    | None -> "unknown"
  in
  let cn_commit = match Cn_ffi.Child_process.exec "git -C $(npm root -g)/cnagent rev-parse --short HEAD 2>/dev/null" with
    | Some c -> String.trim c
    | None -> "unknown"
  in
  let peers_path = Cn_ffi.Path.join hub_path "state/peers.md" in
  let peer_count = match Cn_ffi.Fs.exists peers_path with
    | true ->
        let content = Cn_ffi.Fs.read peers_path in
        let lines = String.split_on_char '\n' content in
        lines |> List.filter (fun l -> String.length l > 2 && String.sub l 0 2 = "- ") |> List.length
    | false -> 0
  in
  let content = Printf.sprintf {|# Runtime State

Auto-generated by cn. Do not edit manually.

```yaml
last_sync: %s
cn_version: %s
cn_commit: %s
template_version: %s
openclaw_version: %s
hub_name: %s
hub_commit: %s
peer_count: %d
```
|} (Cn_fmt.now_iso ()) cn_ver cn_commit cn_ver oc_ver hub_name hub_commit peer_count in
  Cn_ffi.Fs.write runtime_path content;
  print_endline (Cn_fmt.ok "Updated state/runtime.md")

(* === Status === *)

let run_status hub_path name =
  print_endline (Cn_fmt.info (Printf.sprintf "cn hub: %s" name));
  print_endline "";
  Printf.printf "hub..................... %s\n" (Cn_fmt.green Cn_fmt.check);
  Printf.printf "name.................... %s %s\n" (Cn_fmt.green Cn_fmt.check) name;
  Printf.printf "path.................... %s %s\n" (Cn_fmt.green Cn_fmt.check) hub_path;
  print_endline "";
  print_endline (Cn_fmt.dim (Printf.sprintf "[status] ok version=%s" version))

(* === Doctor === *)

type check_result = { name: string; passed: bool; value: string }

let run_doctor hub_path =
  Printf.printf "cn v%s\n" version;
  print_endline (Cn_fmt.info "Checking health...");
  print_endline "";

  let checks = [
    (match Cn_ffi.Child_process.exec "git --version" with
     | Some v ->
         let trimmed = String.trim v in
         let value = match strip_prefix ~prefix:"git version " trimmed with
           | Some rest -> rest | None -> trimmed in
         { name = "git"; passed = true; value }
     | None -> { name = "git"; passed = false; value = "not installed" });

    (match Cn_ffi.Child_process.exec "git config user.name" with
     | Some v -> { name = "git user.name"; passed = true; value = String.trim v }
     | None -> { name = "git user.name"; passed = false; value = "not set" });

    (match Cn_ffi.Child_process.exec "git config user.email" with
     | Some v -> { name = "git user.email"; passed = true; value = String.trim v }
     | None -> { name = "git user.email"; passed = false; value = "not set" });

    { name = "hub directory"; passed = Cn_ffi.Fs.exists hub_path;
      value = if Cn_ffi.Fs.exists hub_path then "exists" else "not found" };

    (let yaml_path = Cn_ffi.Path.join hub_path ".cn/config.yaml" in
     let json_path = Cn_ffi.Path.join hub_path ".cn/config.json" in
     let has_yaml = Cn_ffi.Fs.exists yaml_path in
     let has_json = Cn_ffi.Fs.exists json_path in
     { name = ".cn/config"; passed = has_yaml || has_json;
       value = if has_yaml then "config.yaml"
               else if has_json then "config.json (migrate to .yaml)"
               else "missing" });

    (let p = Cn_ffi.Path.join hub_path "spec/SOUL.md" in
     { name = "spec/SOUL.md"; passed = Cn_ffi.Fs.exists p;
       value = if Cn_ffi.Fs.exists p then "exists" else "missing (optional)" });

    (let p = Cn_ffi.Path.join hub_path "state/peers.md" in
     if Cn_ffi.Fs.exists p then
       let count = Cn_ffi.Fs.read p |> String.split_on_char '\n'
         |> List.filter (fun l -> starts_with ~prefix:"- name:" (String.trim l))
         |> List.length in
       { name = "state/peers.md"; passed = true; value = Printf.sprintf "%d peer(s)" count }
     else { name = "state/peers.md"; passed = false; value = "missing" });

    (match Cn_ffi.Child_process.exec_in ~cwd:hub_path "git remote get-url origin" with
     | Some _ -> { name = "origin remote"; passed = true; value = "configured" }
     | None -> { name = "origin remote"; passed = false; value = "not configured" });
  ] in

  let width = 22 in
  checks |> List.iter (fun c ->
    let dots = String.make (max 1 (width - String.length c.name)) '.' in
    let status = if c.passed then Cn_fmt.green (Cn_fmt.check ^ " " ^ c.value) else Cn_fmt.red (Cn_fmt.cross ^ " " ^ c.value) in
    Printf.printf "%s%s %s\n" c.name dots status);

  print_endline "";
  let fails = checks |> List.filter (fun c -> not c.passed) |> List.length in
  let oks = List.length checks - fails in
  (if fails = 0 then print_endline (Cn_fmt.ok "All critical checks passed.")
   else print_endline (Cn_fmt.fail (Printf.sprintf "%d issue(s) found." fails)));
  print_endline (Cn_fmt.dim (Printf.sprintf "[status] ok=%d warn=0 fail=%d version=%s" oks fails version))

(* === Sync === *)

let run_sync hub_path name =
  print_endline (Cn_fmt.info "Syncing...");
  Cn_mail.inbox_check hub_path name;
  Cn_mail.inbox_process hub_path;
  Cn_mail.outbox_flush hub_path name;
  update_runtime hub_path;
  let _ = Cn_ffi.Child_process.exec_in ~cwd:hub_path "git add -A" in
  let commit_result = Cn_ffi.Child_process.exec_in ~cwd:hub_path "git commit -m 'heartbeat' --allow-empty" in
  (match commit_result with
   | Some _ ->
       let _ = Cn_ffi.Child_process.exec_in ~cwd:hub_path "git push origin 2>/dev/null" in
       ()
   | None -> ());
  print_endline (Cn_fmt.ok "Sync complete")

(* === Setup === *)

let run_setup hub_path =
  let uid = match Cn_ffi.Child_process.exec "id -u" with
    | Some s -> String.trim s
    | None -> "unknown"
  in
  if uid <> "0" then begin
    print_endline (Cn_fmt.fail "Setup requires root. Run: sudo cn setup");
    Cn_ffi.Process.exit 1
  end;

  print_endline (Cn_fmt.info "Setting up cn system components...");

  let logrotate_config = {|/var/log/cn-*.log {
    daily
    rotate 7
    compress
    missingok
    notifempty
}
|} in
  let logrotate_path = "/etc/logrotate.d/cn" in
  Cn_ffi.Fs.write logrotate_path logrotate_config;
  print_endline (Cn_fmt.ok (Printf.sprintf "Created %s" logrotate_path));

  let cron_line = Printf.sprintf "*/5 * * * * cn-cron %s" hub_path in
  let cmd = Printf.sprintf "echo '%s' | crontab -" cron_line in
  (match Cn_ffi.Child_process.exec cmd with
   | Some _ -> print_endline (Cn_fmt.ok "Crontab configured")
   | None -> print_endline (Cn_fmt.warn "Crontab update failed - configure manually"));

  print_endline "";
  print_endline (Cn_fmt.ok "Setup complete!");
  print_endline "";
  print_endline "Configured:";
  print_endline (Printf.sprintf "  • Logrotate: %s" logrotate_path);
  print_endline (Printf.sprintf "  • Cron: */5 * * * * cn-cron %s" hub_path);
  print_endline "";
  print_endline "Logs will be written to: /var/log/cn-YYYYMMDD.log"

(* === Update === *)

let update_cron hub_path =
  let cron_line = Printf.sprintf "*/5 * * * * cn-cron %s" hub_path in
  print_endline (Cn_fmt.info "Updating crontab (5 min intervals)...");
  let cmd = Printf.sprintf "echo '%s' | crontab -" cron_line in
  match Cn_ffi.Child_process.exec cmd with
  | Some _ -> print_endline (Cn_fmt.ok "Crontab updated")
  | None -> print_endline (Cn_fmt.warn "Crontab update failed - update manually")

let run_update () =
  print_endline (Cn_fmt.info "Checking for updates...");

  print_endline (Printf.sprintf "Current version: %s" version);

  let install_dir = "/usr/local/lib/cnos" in
  let fetch_cmd = Printf.sprintf "cd %s && git fetch origin main --quiet 2>&1" install_dir in
  let _ = Cn_ffi.Child_process.exec fetch_cmd in
  let version_cmd = Printf.sprintf "cd %s && git show origin/main:src/lib/cn_lib.ml 2>/dev/null | grep 'let version' | head -1 | sed 's/.*\"\\([^\"]*\\)\".*/\\1/'" install_dir in
  match Cn_ffi.Child_process.exec version_cmd with
  | None ->
      print_endline (Cn_fmt.fail "Could not check for updates. Is cnos installed via git?");
      Cn_ffi.Process.exit 1
  | Some latest_raw ->
      let latest = String.trim latest_raw in
      match latest = version with
      | true -> print_endline (Cn_fmt.ok "Already up to date")
      | false ->
          print_endline (Cn_fmt.info (Printf.sprintf "New version available: %s" latest));
          print_endline (Cn_fmt.info "Updating via git...");
          let install_dir = "/usr/local/lib/cnos" in
          let pull_cmd = Printf.sprintf "cd %s && git pull --ff-only 2>&1" install_dir in
          match Cn_ffi.Child_process.exec pull_cmd with
          | Some _ -> print_endline (Cn_fmt.ok (Printf.sprintf "Updated to v%s" latest))
          | None -> print_endline (Cn_fmt.fail "Update failed. Try: cd /usr/local/lib/cnos && git pull")

let run_update_with_cron hub_path =
  run_update ();
  update_cron hub_path;
  update_runtime hub_path;
  print_endline (Cn_fmt.info "Auto-committing runtime changes...");
  let _ = Cn_ffi.Child_process.exec_in ~cwd:hub_path "git add state/runtime.md" in
  let commit_result = Cn_ffi.Child_process.exec_in ~cwd:hub_path "git commit -m 'chore: cn update runtime'" in
  match commit_result with
  | Some _ ->
      print_endline (Cn_fmt.ok "Committed runtime changes");
      (match Cn_ffi.Child_process.exec_in ~cwd:hub_path "git remote get-url origin 2>/dev/null" with
       | Some _ ->
           print_endline (Cn_fmt.info "Pushing to origin...");
           (match Cn_ffi.Child_process.exec_in ~cwd:hub_path "git push origin HEAD 2>&1" with
            | Some _ -> print_endline (Cn_fmt.ok "Pushed to origin")
            | None -> print_endline (Cn_fmt.warn "Push failed - push manually"))
       | None -> print_endline (Cn_fmt.dim "No origin remote - skipping push"))
  | None -> print_endline (Cn_fmt.dim "No runtime changes to commit")

(* === Self-Update Check === *)

let self_update_check () =
  let args = Cn_ffi.Process.argv |> Array.to_list in
  let is_skip_cmd = List.exists (fun a ->
    a = "--help" || a = "-h" || a = "--version" || a = "-V" || a = "help"
  ) args in
  if is_skip_cmd then ()
  else
    let install_dir = "/usr/local/lib/cnos" in
    if not (Sys.file_exists install_dir) then ()
    else
    let fetch_cmd = Printf.sprintf "cd %s && git fetch origin main --quiet 2>/dev/null" install_dir in
    let _ = Cn_ffi.Child_process.exec fetch_cmd in
    let version_cmd = Printf.sprintf "cd %s && git show origin/main:src/lib/cn_lib.ml 2>/dev/null | grep 'let version' | head -1 | sed 's/.*\"\\([^\"]*\\)\".*/\\1/'" install_dir in
    match Cn_ffi.Child_process.exec version_cmd with
    | None -> ()
    | Some latest_raw ->
        let latest = String.trim latest_raw in
        if latest <> version && latest <> "" then begin
          print_endline (Cn_fmt.info (Printf.sprintf "Updating cn %s → %s..." version latest));
          let pull_cmd = Printf.sprintf "cd %s && git pull --ff-only 2>/dev/null" install_dir in
          match Cn_ffi.Child_process.exec pull_cmd with
          | Some _ ->
              print_endline (Cn_fmt.ok (Printf.sprintf "Updated to cn %s" latest));
              let args_str = args |> List.tl |> String.concat " " in
              let _ = Cn_ffi.Child_process.exec (Printf.sprintf "cn %s" args_str) in
              Cn_ffi.Process.exit 0
          | None ->
              print_endline (Cn_fmt.warn "Self-update failed - continuing with current version")
        end

(* === Init === *)

let run_init name =
  let hub_name = match name with
    | Some n -> n
    | None -> Cn_ffi.Path.basename (Cn_ffi.Process.cwd ())
  in
  let hub_dir = "cn-" ^ hub_name in

  if Cn_ffi.Fs.exists hub_dir then begin
    print_endline (Cn_fmt.fail (Printf.sprintf "Directory %s already exists" hub_dir));
    Cn_ffi.Process.exit 1
  end;

  print_endline (Cn_fmt.info (Printf.sprintf "Initializing hub: %s" hub_name));

  Cn_ffi.Fs.mkdir_p hub_dir;
  Cn_ffi.Fs.mkdir_p (Cn_ffi.Path.join hub_dir ".cn");
  Cn_ffi.Fs.mkdir_p (Cn_ffi.Path.join hub_dir "spec");
  Cn_ffi.Fs.mkdir_p (Cn_ffi.Path.join hub_dir "state");
  Cn_ffi.Fs.mkdir_p (Cn_ffi.Path.join hub_dir "threads/in");
  Cn_ffi.Fs.mkdir_p (Cn_ffi.Path.join hub_dir "threads/mail/inbox");
  Cn_ffi.Fs.mkdir_p (Cn_ffi.Path.join hub_dir "threads/mail/outbox");
  Cn_ffi.Fs.mkdir_p (Cn_ffi.Path.join hub_dir "threads/mail/sent");
  Cn_ffi.Fs.mkdir_p (Cn_ffi.Path.join hub_dir "threads/reflections/daily");
  Cn_ffi.Fs.mkdir_p (Cn_ffi.Path.join hub_dir "threads/reflections/weekly");
  Cn_ffi.Fs.mkdir_p (Cn_ffi.Path.join hub_dir "threads/reflections/monthly");
  Cn_ffi.Fs.mkdir_p (Cn_ffi.Path.join hub_dir "threads/adhoc");
  Cn_ffi.Fs.mkdir_p (Cn_ffi.Path.join hub_dir "threads/archived");
  Cn_ffi.Fs.mkdir_p (Cn_ffi.Path.join hub_dir "logs");

  let config = Printf.sprintf {|name: %s
version: 1.0.0
created: %s
|} hub_name (Cn_fmt.now_iso ()) in
  Cn_ffi.Fs.write (Cn_ffi.Path.join hub_dir ".cn/config.yaml") config;

  let soul = Printf.sprintf {|# SOUL.md - Core Contract

*%s is an agent on the Coherent Network.*

## Identity

- **Name:** %s
- **Role:** (define your role)
- **Mode:** Collaborative

## What %s Does

- (define responsibilities)

## Conduct

- Be genuinely helpful
- Be resourceful before asking
- Earn trust through competence
|} hub_name hub_name hub_name in
  Cn_ffi.Fs.write (Cn_ffi.Path.join hub_dir "spec/SOUL.md") soul;

  let user = {|# USER.md - About Your Human

- **Name:** (your human's name)
- **Timezone:** (timezone)

## Preferences

- **Communication:** (style)
- **Autonomy:** (level)
|} in
  Cn_ffi.Fs.write (Cn_ffi.Path.join hub_dir "spec/USER.md") user;

  let peers = Printf.sprintf {|# Peers

Agents and repos this hub communicates with.

- name: cn-agent
  hub: https://github.com/usurobor/cn-agent.git
  kind: template
|} in
  Cn_ffi.Fs.write (Cn_ffi.Path.join hub_dir "state/peers.md") peers;

  let _ = Cn_ffi.Child_process.exec_in ~cwd:hub_dir "git init -b main" in

  update_runtime hub_dir;

  let _ = Cn_ffi.Child_process.exec_in ~cwd:hub_dir "git add -A" in
  let _ = Cn_ffi.Child_process.exec_in ~cwd:hub_dir (Printf.sprintf "git commit -m 'Initialize %s hub'" hub_name) in

  print_endline (Cn_fmt.ok (Printf.sprintf "Created hub: %s" hub_dir));
  print_endline (Cn_fmt.info "Next steps:");
  print_endline (Printf.sprintf "  cd %s" hub_dir);
  print_endline "  git remote add origin <your-repo-url>";
  print_endline "  git push -u origin main"
